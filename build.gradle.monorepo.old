// adapted from EnderIO, thanks for the great example! (https://github.com/SleepyTrousers/EnderIO)

buildscript {
    repositories {
        jcenter()
        mavenCentral()
        maven {
            name = "forge"
            url = "http://files.minecraftforge.net/maven"
        }
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '4.1.+', changing: true
        classpath "gradle.plugin.net.intellisun:modDependencies:1.0.1-alpha.2" // https://github.com/IntelliSun-MC/modDependencies
        classpath 'org.junit.platform:junit-platform-gradle-plugin:1.0.3'
    }
}

plugins {
    id 'com.matthewprenger.cursegradle' version "1.1.0"
    id "com.dorongold.task-tree" version "1.5"
}

apply plugin: 'idea'

// More user properties
//ext.user = parseConfig(file('user.properties'))
//if (ext.user != null) {
//    ext.user.each { k, v ->
//        project.ext.set(k, v)
//    }
//}

def release = System.getenv("RELEASE") != null &&
        !System.getenv("RELEASE").equalsIgnoreCase("false")

// Configure all projects
subprojects {
    apply plugin: 'net.minecraftforge.gradle'
    apply plugin: 'net.intellisun.moddependencies'
    apply plugin: 'org.junit.platform.gradle.plugin'

    // Import mod dependencies and execute
    if (file('dependencies.gradle').exists())
        apply from: 'dependencies.gradle'

    group = 'net.dandoes.minecraft'
    version = getVersionString(project)
    archivesBaseName = getArchiveBaseName(project)

    // Configure minecraft pipeline
//    minecraft {
//        mappings channel: 'official', version: minecraft_version
////        runDir = "run"
//
//        // Replace the version string in source
////        replace '@VERSION@', project.version
//
//        // If the module defines `dependencyString` use it
////        if (project.hasProperty('dependencyString'))
////            replace 'DEFAULT_DEPENDENCIES;', "\"${dependencyString}\";"
//        runs {
//            client {
//                workingDirectory project.file('run')
//
//                // Recommended logging data for a userdev environment
//                // The markers can be changed as needed.
//                // "SCAN": For mods scan.
//                // "REGISTRIES": For firing of registry events.
//                // "REGISTRYDUMP": For getting the contents of all registries.
//                property 'forge.logging.markers', 'REGISTRIES'
//
//                // Recommended logging level for the console
//                // You can set various levels here.
//                // Please read: https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
//                property 'forge.logging.console.level', 'debug'
//
//                mods {
//                    dandoes_minigame_codslap {
//                        source sourceSets.main
//                    }
//                    dandoes_minigame {
//                        source sourceSets.main
//                    }
//                    dandoes_nodesupport {
//                        source sourceSets.main
//                    }
//                }
//            }
//
//            server {
//                workingDirectory project.file('run')
//
//                // Recommended logging data for a userdev environment
//                // The markers can be changed as needed.
//                // "SCAN": For mods scan.
//                // "REGISTRIES": For firing of registry events.
//                // "REGISTRYDUMP": For getting the contents of all registries.
//                property 'forge.logging.markers', 'REGISTRIES'
//
//                // Recommended logging level for the console
//                // You can set various levels here.
//                // Please read: https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
//                property 'forge.logging.console.level', 'debug'
//
//                mods {
//                    dandoes_minigame_codslap {
//                        source sourceSets.main
//                    }
//                    dandoes_minigame {
//                        source sourceSets.main
//                    }
//                    dandoes_nodesupport {
//                        source sourceSets.main
//                    }
//                }
//            }
//
//            data {
//                println('RUNS -> DATA')
//                workingDirectory project.file('run')
//
//                // Recommended logging data for a userdev environment
//                // The markers can be changed as needed.
//                // "SCAN": For mods scan.
//                // "REGISTRIES": For firing of registry events.
//                // "REGISTRYDUMP": For getting the contents of all registries.
//                property 'forge.logging.markers', 'REGISTRIES'
//
//                // Recommended logging level for the console
//                // You can set various levels here.
//                // Please read: https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
//                property 'forge.logging.console.level', 'debug'
//
//                // Specify the modid for data generation, where to output the resulting resource, and where to look for existing resources.
//                args '--mod', 'dandoes_minigame_codslap', '--all', '--output', file('src/generated/resources/'), '--existing', file('src/main/resources/')
//
//                mods {
//                    dandoes_minigame_codslap {
//                        source sourceSets.main
//                    }
//                    dandoes_minigame {
//                        source sourceSets.main
//                    }
//                    dandoes_nodesupport {
//                        source sourceSets.main
//                    }
//                }
//            }
//        }
//    }

    // The is very temporary, currently not all modules compile
    // This will exclude all non compiling modules from CI but
    // they will still appear is IDEs.
    // TODO: Remove this once all modules compile
    if (!project.hasProperty('include_in_build'))
        project.ext.include_in_build = true
    else
        project.ext.include_in_build = project.include_in_build != 'false'

    if (!project.hasProperty('include_in_combjar'))
        project.ext.include_in_combjar = true
    else
        project.ext.include_in_combjar = project.include_in_combjar != 'false'

    if (!project.hasProperty('publish_api'))
        project.ext.publish_api = true
    else
        project.ext.publish_api = project.publish_api != 'false'

    project.ext.include_in_combjar = project.ext.include_in_combjar && project.ext.include_in_build

    // Eclipse needs this for some reason
//    sourceCompatibility = targetCompatibility = JavaVersion.VERSION_1_8
    compileJava {
        sourceCompatibility = targetCompatibility = JavaVersion.VERSION_1_8
    }

    repositories {
        mavenCentral()
//        maven { url = "http://files.minecraftforge.net/maven" }
//        mavenLocal()

        maven {
            name = "forge"
            url = "http://files.minecraftforge.net/maven"
        }
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }

    configurations {
        // configuration that holds jars to embed inside the jar
        embed
    }

    junitPlatform {
        platformVersion '1.0.3'
        enableStandardTestTask true
    }

    // Common dependencies for all modules
    dependencies {
        minecraft "net.minecraftforge:forge:${minecraft_version}-${forge_version}"

        // All jars in the '<module>/lib' directory
//        compile fileTree(dir: "lib", include: '*.jar')

        // All jars in the '<root>/lib' directory
//        compile fileTree(dir: "${project.rootDir}/lib", include: '*.jar')

        testImplementation     "org.junit.jupiter:junit-jupiter-api:5.2.0"
        testCompile("org.junit.jupiter:junit-jupiter-api:5.2.0")
        testCompile("org.junit.platform:junit-platform-launcher:1.1.0")
        testRuntime("org.junit.jupiter:junit-jupiter-engine:5.2.0")
    }

    // Process resources to inject dynamic metadata
    processResources {
        // Rerun this step every time these change
        // TODO: figure out how to do this for mods.toml
        // inputs.property "version", project.version
        // inputs.property "mcversion", project.minecraft.version

        // Inject version and mcversion to mod info
        from(sourceSets.main.resources.srcDirs) {
            include '**/*.info'
            include '**/*.properties'

            // TODO: figure out how to do this for mods.toml
            // expand 'version': project.version, 'mcversion': project.minecraft.version
        }

        // Include everything else as is
        from(sourceSets.main.resources.srcDirs) {
            exclude '**/*.info'
            exclude '**/*.properties'
        }
    }

    // Java 8 throws errors about jdoc, ignore them
    if (JavaVersion.current().isJava8Compatible()) {
        tasks.withType(Javadoc) {
            options.addStringOption('Xdoclint:none', '-quiet')
        }
    }

    // Build the key store for jar signing
//    task mkKeyStore(type: Exec) {
//        workingDir projectDir
//        commandLine 'keytool', '-genkey', '-storetype', 'PKCS12', '-alias', 'signFiles', '-keystore', 'eiostore.jks', '-storepass', '123456', '-noprompt', '-dname', 'CN='+getCN(), '-keypass', '123456'
//    }

    // Sign the jar with the new key store
//    task signJar(type: SignJar, dependsOn: reobfJar) {
//        inputFile = jar.archivePath
//        outputFile = jar.archivePath
//        keyStore = 'eiostore.jks'
//        alias = 'signFiles'
//        storePass = '123456'
//        keyPass = '123456'
//    }

    // Cleanup the keystore
//    task rmKeyStorePre(type: Delete) {
//        delete 'eiostore.jks'
//    }

    // Cleanup the keystore
//    task rmKeyStore(type: Delete) {
//        delete 'eiostore.jks'
//    }

//    build.dependsOn rmKeyStore
//    rmKeyStore.dependsOn signJar
//    signJar.dependsOn mkKeyStore
//    mkKeyStore.dependsOn rmKeyStorePre

    // this needs to be here for cursegradle.addArtifact to be able to reference it
    task recipeJar(type: Jar, dependsOn: jar) {
        classifier = 'recipes'
        extension = 'zip'
        enabled = rootProject == project

        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    }


    // Note that subprojects inherit this ID, so check that it's not an inherited value if we don't want it to be published with the same ID as the
    // top-level project. Which wouldn't work as it would generate duplicate tasks.
    if (project.curse_projectId?.trim() && (rootProject == project || rootProject.curse_projectId != project.curse_projectId))
        curseforge {
            options {
                debug = !release
            }
            apiKey = project.hasProperty('curseforge_key') ? project.curseforge_key : ""

            def build_number = System.getenv('BUILD_NUMBER') == null ? '0' : System.getenv('BUILD_NUMBER')
            def changelog_content = System.getenv('CHANGELOG') != null && !System.getenv('CHANGELOG').equals('none') ? System.getenv('CHANGELOG') : ''

            def changelog_text = getChangelogFormat()
                    .replaceAll('#BUILD#', build_number)
                    .replaceAll('#EXTRA#', changelog_content)

            project {
                id = project.curse_projectId
                changelog = changelog_text
                changelogType = 'html'
                releaseType = 'release'

                mainArtifact(jar) {
//                    String display_addon = project.hasProperty('curse_display_name') ? project.curse_display_name : "Ender IO";
//                    displayName = "${display_addon} - ${minecraft_version}"
                }
                if (rootProject == project) {
                    addArtifact(recipeJar)
                }

//                relations {
//                    if (project.hasProperty('curse_optional_libraries'))
//                        project.curse_optional_libraries.split(/,\s*/).findAll { it?.trim() }.each { slug -> optionalLibrary slug }
//                    if (project.hasProperty('curse_required_libraries'))
//                        project.curse_required_libraries.split(/,\s*/).findAll { it?.trim() }.each { slug -> requiredLibrary slug }
//                }

                afterEvaluate {
                    // no, addArtifact() will not work in here

//     Work around https://github.com/matthewprenger/CurseGradle/issues/20
//     TODO: This only works for the root project.
                    gameVersionStrings.remove('Java 9')
// (1) Work around cursegradle setting dependencies for the curseforgeXXX tasks to :subproject:jar and :reobfJar -> force :subproject:reobfJar instead.
// (2) Depend on rmKeyStore instead of reobfJar so the signed jar is uploaded.
// (3) It is very tricky to not run too early (before cursegradle creates the upload task), that's why this looks so convoluted...
//                    allprojects { p ->
//                        p.curseforge.curseProjects.findAll { it.uploadTask }.findAll { it.uploadTask.projectId == p.curse_projectId }.each { curseProject ->
//                            Task reobfTask = p.tasks.findByName('rmKeyStore')
//                            // println "Forcing dependency of ${curseProject.uploadTask} to ${reobfTask}"
//                            curseProject.uploadTask.dependsOn.clear()
//                            curseProject.uploadTask.dependsOn reobfTask
//                        }
//                    }
                }
            }
        }

}

// Configuration that applies only to modules
subprojects {

//    jar {
//        into('/META-INF/libraries') {
//            from configurations.embed
//        }
//
//        doFirst {
//            manifest {
//                def contained = configurations.embed.collect { it.getName() };
//                if (!contained.isEmpty()) {
//                    attributes([
//                            "ContainedDeps": contained.join(' ')
//                    ])
//                }
//            }
//        }
//    }

    // Assembly an API jar
//    task apiJar(type: Jar) {
//        enabled = project.ext.publish_api
//        classifier = 'api'
//
//        from sourceSets.main.output.classesDirs
//        include 'net/dandoes/minecraft/**/*.class'
//        from sourceSets.main.java
//        include 'net/dandoes/minecraft/**/*.java'
//    }

    // Assemble a source jar
    task sourcesJar(type: Jar) {
        enabled = false
        classifier = 'sources'
        from sourceSets.main.java
    }
}

apply plugin: 'net.minecraftforge.gradle'

dependencies {
    minecraft "net.minecraftforge:forge:${minecraft_version}-${forge_version}"
}

// Configure minecraft pipeline
minecraft {
    mappings channel: 'official', version: minecraft_version
//        runDir = "run"

    // Replace the version string in source
//        replace '@VERSION@', project.version

    // If the module defines `dependencyString` use it
//        if (project.hasProperty('dependencyString'))
//            replace 'DEFAULT_DEPENDENCIES;', "\"${dependencyString}\";"
    runs {
        client {
            workingDirectory project.file('run')

            // Recommended logging data for a userdev environment
            // The markers can be changed as needed.
            // "SCAN": For mods scan.
            // "REGISTRIES": For firing of registry events.
            // "REGISTRYDUMP": For getting the contents of all registries.
            property 'forge.logging.markers', 'REGISTRIES'

            // Recommended logging level for the console
            // You can set various levels here.
            // Please read: https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
            property 'forge.logging.console.level', 'debug'

            mods {
                dandoes_minigame_codslap {
                    source sourceSets.main
                }
                dandoes_minigame {
                    source sourceSets.main
                }
                dandoes_nodesupport {
                    source sourceSets.main
                }
            }
        }

        server {
            workingDirectory project.file('run')

            // Recommended logging data for a userdev environment
            // The markers can be changed as needed.
            // "SCAN": For mods scan.
            // "REGISTRIES": For firing of registry events.
            // "REGISTRYDUMP": For getting the contents of all registries.
            property 'forge.logging.markers', 'REGISTRIES'

            // Recommended logging level for the console
            // You can set various levels here.
            // Please read: https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
            property 'forge.logging.console.level', 'debug'

            mods {
                dandoes_minigame_codslap {
                    source sourceSets.main
                }
                dandoes_minigame {
                    source sourceSets.main
                }
                dandoes_nodesupport {
                    source sourceSets.main
                }
            }
        }

        data {
            println('RUNS -> DATA')
            workingDirectory project.file('run')

            // Recommended logging data for a userdev environment
            // The markers can be changed as needed.
            // "SCAN": For mods scan.
            // "REGISTRIES": For firing of registry events.
            // "REGISTRYDUMP": For getting the contents of all registries.
            property 'forge.logging.markers', 'REGISTRIES'

            // Recommended logging level for the console
            // You can set various levels here.
            // Please read: https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
            property 'forge.logging.console.level', 'debug'

            // Specify the modid for data generation, where to output the resulting resource, and where to look for existing resources.
            args '--mod', 'dandoes_minigame_codslap', '--all', '--output', file('src/generated/resources/'), '--existing', file('src/main/resources/')

            mods {
                dandoes_minigame_codslap {
                    source sourceSets.main
                }
                dandoes_minigame {
                    source sourceSets.main
                }
                dandoes_nodesupport {
                    source sourceSets.main
                }
            }
        }
    }

//    prepareRunServer.dependsOn ':codslap:prepareRunServer'
//    prepareRunServer.dependsOn ':minigame:prepareRunServer'
//    prepareRunServer.dependsOn ':nodesupport:prepareRunServer'

}

// Part of the temporary fix for not compiling modules
def buildprojects = subprojects.findAll { sp -> sp.ext.include_in_build }
//def combjarprojects = subprojects.findAll { sp -> sp.ext.include_in_combjar }

// Make sure all modules are configured
buildprojects.each { subproject -> evaluationDependsOn( subproject.path ) }

//jar.doFirst {
//    // This code merge all resources that are duplicated across the modules.
//    // Since modules are shipped both as separate modules and as an 'all' jar
//    // some manifest files are duplicated.
//    File target = new File(project.sourceSets.main.output.resourcesDir, "assets/dandoes/lang")
//    target.mkdirs()
//    combjarprojects.each { subproject ->
//        File langDir = new File(subproject.sourceSets.main.output.resourcesDir, 'assets/dandoes/lang/')
//        if (langDir.exists()) {
//            langDir.eachFileMatch( ~".*\\.lang\$" ) { langfile ->
//                new File(target, langfile.name) << langfile.text << "\n"
//            }
//        }
//    }

    // FIXME: need to do this for mods.toml ... or maybe not because I don't think I want to merge jars?
    // def mcmod = ""
    // combjarprojects.each { subproject ->
    //     mcmod += new File(subproject.sourceSets.main.output.resourcesDir, 'mcmod.info').text
    // }
    // new File(project.sourceSets.main.output.resourcesDir, "mcmod.info") << mcmod.replaceAll(/\]\s*\[/, ',')

//    def sound = ""
//    combjarprojects.each { subproject ->
//        File soundFile = new File(subproject.sourceSets.main.output.resourcesDir, 'assets/dandoes/sounds.json')
//        if (soundFile.exists()) {
//            sound += soundFile.text
//        }
//    }
//    new File(project.sourceSets.main.output.resourcesDir, "assets/dandoes/sounds.json") << sound.replaceAll(/\}\s*\{/, ',')

//    println "Created derived resources in ${target}"
//}

// Collect all sources from the modules and merge them
// into the all jar.
//jar.dependsOn combjarprojects.tasks['classes']
//jar {
//    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
//    combjarprojects.each { subproject ->
//        from subproject.sourceSets.main.output.classesDirs
//        from subproject.sourceSets.main.output.resourcesDir
//
//        into('/META-INF/libraries') {
//            from subproject.configurations.embed
//        }
//    }
//    doFirst {
//        manifest {
//            attributes([
//                    "ContainedDeps": combjarprojects.collect { it.configurations.embed.collect { it.getName() }}.flatten().join(' ')
//            ])
//        }
//    }
//}

//sourceJar {
//    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
//    combjarprojects.each { subproject ->
//        from subproject.sourceSets.main.java
//    }
//}

// recipeJar real content. must be here so it can use buildprojects
//buildprojects.each { subproject ->
//    recipeJar.from subproject.sourceSets.main.output.resourcesDir, {
//        include 'assets/dandoes/config/recipes/*.xml'
//        include 'assets/dandoes/config/recipes/*.xsd'
//    }
//}

// Copy all the jars to `libs`
//task copyJars(type: Copy, dependsOn: subprojects.tasks['signJar']) {
task copyLibJars(type: Copy, dependsOn: subprojects.tasks['jar']) {
    from buildprojects.collect { it.tasks.withType(Jar) }
    into project.file('build/libs').path
}
task copyRunJars(type: Copy, dependsOn: subprojects.tasks['jar']) {
    from buildprojects.collect { it.tasks.withType(Jar) }
    into project.file('run/mods').path
}
task copyJars {}
copyJars.dependsOn copyLibJars, copyRunJars


// Combine all the API jars into a single jar
//task combApiJar(type: Jar) {
//    dependsOn copyJars
//    classifier 'api'
//    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
//    combjarprojects.each { subproject ->
//        if (subproject.apiJar.enabled)
//            from zipTree(subproject.apiJar.getArchivePath()).asFileTree
//    }
//}

//artifacts {
//    archives combApiJar
//}

//build.dependsOn sourceJar, combApiJar, recipeJar
//build.dependsOn sourceJar

//eclipseFactorypath.dependsOn cleanEclipseFactorypath, eclipseJdtApt, eclipseJdt // workaround for gradle <5.4
// gradle 5.4+:
// eclipse.synchronizationTasks ap:build, cleanEclipseFactorypath, eclipseFactorypath, eclipseJdtApt, eclipseJdt


//apply plugin: 'maven-publish'
//
//publishing {
//    tasks.publish.dependsOn 'build'
//    publications {
//        mavenJava(MavenPublication) {
//            from components.java                                //Define the properties of the publication
//            version minecraft_version + "-" + project.version
//            artifact sourceJar
//            artifact combApiJar
//            artifact recipeJar
//
//            pom.withXml { //Here we can add custom nodes to the pom file
//                def dependenciesNode = asNode().getAt("dependencies")[0]
//                if (dependenciesNode == null) {
//                    dependenciesNode = asNode().appendNode('dependencies')
//                }
//
//                //Iterate over the compile dependencies (we don't want the test ones), adding a <dependency> node for each
//                configurations.compile.allDependencies.each {
//                    if (!it.name.equals("unspecified")) { //filter out the garbage
//                        def dependencyNode = dependenciesNode.appendNode('dependency')
//                        dependencyNode.appendNode('groupId', it.group)
//                        dependencyNode.appendNode('artifactId', it.name)
//                        dependencyNode.appendNode('version', it.version)
//                    }
//                }
//            }
//        }
//    }
//
//    repositories {
////        if (project.hasProperty('mavendir')) println "maven_publish: mavendir is set"
////        if (project.hasProperty('maven2_url')) println "maven_publish: maven2_url is set (and ignored)"
////        if (project.hasProperty('maven2_user')) println "maven_publish: maven2_user is set"
////        if (project.hasProperty('maven2_pass')) println "maven_publish: maven2_pass is set"
////        if (System.getenv('MAVEN_GITHUB_USER') != null) println "maven_publish: MAVEN_GITHUB_USER is set"
////        if (System.getenv('MAVEN_GITHUB_TOKEN') != null) println "maven_publish: MAVEN_GITHUB_TOKEN is set"
////        if (release) println "maven_publish: release is set"
//
////        def pub_github = System.getenv('MAVEN_GITHUB_USER') != null && System.getenv('MAVEN_GITHUB_TOKEN') != null
////        if (pub_github) {
////            maven {
////                url uri("https://maven.pkg.github.com/danielschaffer/node-interop-minecraft-mod")
////                credentials {
////                    username System.getenv('MAVEN_GITHUB_USER')
////                    password System.getenv('MAVEN_GITHUB_TOKEN')
////                }
////            }
////        }
////        def pub_maven = release && (project.hasProperty('mavendir') || project.hasProperty('maven2_url'))
////        def pub_maven = release && project.hasProperty('mavendir')
////        if (pub_maven) {
////	        if (project.hasProperty('mavendir')) {
////            maven { url mavendir }
////	        } else if (project.hasProperty('maven2_user') && project.hasProperty('maven2_pass')) {
////                maven {
////                    url maven2_url
////                    credentials {
////                        username maven2_user
////                        password maven2_pass
////                    }
////                }
////            } else {
////                maven { url maven2_url }
////            }
////        }
//        if (!pub_github && !pub_maven) {
//            mavenLocal()
//        }
//    }
//}

//tasks.curseforge.enabled = project.hasProperty('curseforge_key')

//// Part of the temporary fix for not compiling modules
//gradle.taskGraph.whenReady {
//    def tasksToDisable = [
//            'build', 'compileJava', 'assemble', 'sourceJar',
//            'check', 'reobfJar', 'signJar', 'apiJar', 'curseforge'
//    ]
//
//    gradle.taskGraph.allTasks.each {
//        if(!it.project.ext.include_in_build) {
//            if (tasksToDisable.find { n -> it.name == n } != null) it.enabled = false
//        }
//    }
//}

// Generate a random cmmon name for the cert
//String getCN() {
//    def firsts = ['Donald', 'Lex', 'The', 'Arthur', 'Bridget', 'Dorian', 'Ford', 'Guy', 'James', 'Jessica', 'John', 'Michael', 'Robinson', 'Zaphod', 'Bell', 'Penelope']
//    def lasts = ['Duck', 'Luthor', 'Doctor', 'Master', 'Dent', 'Jones', 'Gray', 'Prefect', 'Montag', 'Moriarty', 'Rabbit', 'Watson', 'Smith', 'Corleone', 'Crusoe', 'Beeblebrox', 'Cranel', 'Akk']
//    def rand = new Random()
//    return firsts[rand.nextInt(firsts.size())] + ' ' + lasts[rand.nextInt(lasts.size())]
//}

// This is the new version/module format:
// module name:
//   dandoes-<name>-<mc-version>-<version>
// version:
//   <major>.<minor>.<patch>-<cls>-<hash>
// patch:
//   defaults to 'version_patch'
//   overriten by CI / build server
// cls (classifier):
//   * nightly
//   * dev
//   * ci
//   * snapshot
//   * etc.
// hash:
//   if on a dev machine - the current commit hash

// Examples:
//   * dandoes-base-1.12.2-4.0.1.jar            :: release version 4.0.1 for mc 1.12.2
//   * dandoes-base-1.12.2-4.2.1-nightly-4      :: nightly build no. 4 for version 4.2.1
//   * dandoes-base-1.12.2-4.5.1-dev-c91c8ee6e  :: dev (local) build for commit c91c8ee6e
String getVersionString(Project proj) {
    def build_server = System.getenv('CI') != null || System.getenv('BUILD_NUMBER') != null

    def version_patch_lc = proj.version_patch
    if (System.getenv('BUILD_NUMBER') != null)
        version_patch_lc = System.getenv('BUILD_NUMBER')

    def version_classifier = ''
    if (System.getenv('VERSION_CLS') != null)
        version_classifier = System.getenv('VERSION_CLS')
    else if (System.getenv('NIGHTLY') != null)
        version_classifier = 'nightly'

    def version_hash = ''
    if (!build_server) {
        try {
            version_hash = "git rev-parse --short HEAD".execute().text.trim()
        } catch (all) { }
    }

    def version_base = "${proj.version_major}.${proj.version_minor}.${version_patch_lc}"
    def version_parts = ([ version_base, version_classifier, version_hash ]).findAll { p -> p != '' }

    return String.join('-', version_parts)
}

String getPrettyName(Project proj) {
    def project_base_name = rootProject.name
    if (proj.hasProperty('module_name'))
        project_base_name += "-${proj.module_name}"
    return project_base_name
}

String getArchiveBaseName(Project proj) {
    return getPrettyName(proj) + "-${project.minecraft_version}"
}

String getChangelogFormat() {
    return new File(projectDir, 'doc/changelog.html').getText('UTF-8')
}

// parse and import external config
def parseConfig(File config) {
    if (!config.exists())
        return null

    config.withReader {
        def prop = new Properties()
        prop.load(it)
        return (new ConfigSlurper().parse(prop))
    }
}

def resolveOption(Project project, String option, boolean defaultValue = false) {
    def sourceValue = project.hasProperty(option) ? project.property(option) : defaultValue

    return sourceValue == 'true' || sourceValue == true || sourceValue == 1
}

//jar {
//    jar.finalizedBy('reobfJar')
//}