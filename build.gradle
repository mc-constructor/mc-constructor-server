import net.minecraftforge.gradle.common.util.ModConfig

buildscript {
    repositories {
        maven { url = 'https://maven.minecraftforge.net' }
        maven {
            url "https://plugins.gradle.org/m2/"
        }
        jcenter()
        mavenCentral()
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '4.1.+', changing: true
        classpath 'org.junit.platform:junit-platform-gradle-plugin:1.0.3'
    }
}

apply plugin: 'idea'

// Configure all projects
subprojects {
    apply plugin: 'net.minecraftforge.gradle'

    // Import mod dependencies and execute
//    if (file('dependencies.gradle').exists())
//        apply from: 'dependencies.gradle'

    group = 'net.dandoes.minecraft'
    version = getVersionString(project)
    archivesBaseName = getArchiveBaseName(project)

    compileJava {
        sourceCompatibility = targetCompatibility = JavaVersion.VERSION_1_8
    }
    minecraft {
        mappings channel: 'official', version: minecraft_version

        ModConfig projectMod = new ModConfig(project, project.moduleModId);
        projectMod.source(project.sourceSets.main)

        runs {
            client {
                workingDirectory project.file('run')

                // Recommended logging data for a userdev environment
                // The markers can be changed as needed.
                // "SCAN": For mods scan.
                // "REGISTRIES": For firing of registry events.
                // "REGISTRYDUMP": For getting the contents of all registries.
                property 'forge.logging.markers', 'REGISTRIES'

                // Recommended logging level for the console
                // You can set various levels here.
                // Please read: https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
                property 'forge.logging.console.level', 'debug'

                mods.add(projectMod)
            }

            server {
                workingDirectory project.file('run')

                property 'forge.logging.markers', 'REGISTRIES'
                property 'forge.logging.console.level', 'debug'

                mods.add(projectMod)
            }

            data {
                workingDirectory project.file('run')

                property 'forge.logging.markers', 'REGISTRIES'
                property 'forge.logging.console.level', 'debug'

                // Specify the modid for data generation, where to output the resulting resource, and where to look for existing resources.
                args '--mod', project.moduleModId, '--all', '--output', file('src/generated/resources/'), '--existing', file('src/main/resources/')

                mods.add(projectMod)
            }
        }
    }
    sourceSets.main.resources { srcDir 'src/generated/resources' }

    // Common dependencies for all modules
    dependencies {
        minecraft "net.minecraftforge:forge:${minecraft_version}-${forge_version}"

        testImplementation "org.junit.jupiter:junit-jupiter-api:5.2.0"
        testCompile("org.junit.jupiter:junit-jupiter-api:5.2.0")
        testCompile("org.junit.platform:junit-platform-launcher:1.1.0")
        testRuntime("org.junit.jupiter:junit-jupiter-engine:5.2.0")
    }
}

evaluationDependsOnChildren()

def clientProjects = subprojects.findAll { sp -> sp.includeWithClient == "true" }
def serverProjects = subprojects.findAll { sp -> sp.includeWithServer == "true" }

println("clientProjects:")
clientProjects.each {
    println("  " + it.name)
}
println("serverProjects:")
serverProjects.each {
    println("  " + it.name)
}

task copyServerLibJars(type: Copy, dependsOn: subprojects.tasks['reobfJar']) {
    from serverProjects.collect {it.tasks.withType(Jar) }
    into project.file('build/libs/server').path
}
task copyClientLibJars(type: Copy, dependsOn: subprojects.tasks['reobfJar']) {
    from clientProjects.collect { it.tasks.withType(Jar) }
    into project.file('build/libs/client').path
}
task copyLibJars {
    dependsOn copyServerLibJars, copyClientLibJars
}
task buildLibs {
    dependsOn copyLibJars
}

task copyClientRunJars(type: Copy, dependsOn: clientProjects.tasks['jar']) {
    from clientProjects.collect { it.tasks.withType(Jar) }
    into project.file('run/client/mods').path
}
task copyServerRunJars(type: Copy, dependsOn: serverProjects.tasks['jar']) {
    from serverProjects.collect { it.tasks.withType(Jar) }
    into project.file('run/server/mods').path
}

task prepareRuns(dependsOn: subprojects.tasks['prepareRuns']) {}

task prepareRunClient() {
    clientProjects.each { dependsOn("${it.name}:prepareRunClient") }
    dependsOn copyClientRunJars

}
task prepareRunServer() {
    serverProjects.each { dependsOn("${it.name}:prepareRunServer") }
    dependsOn copyServerRunJars
}

task cleanSubprojects {
    subprojects.each {
        delete project.fileTree('build/libs').matching {
            include "**/*.jar"
        }
        delete project.fileTree('build/reobfJar').matching {
            include "**/*.jar"
        }
    }
}

task cleanLibs {
    dependsOn cleanSubprojects
    delete project.fileTree('build/libs').matching {
        include "**/*.jar"
    }
}

task cleanRun {
    delete project.fileTree('build/run').matching {
        include "*/mods/**/*.jar"
    }
}

String getVersionString(Project proj) {
    def build_server = System.getenv('CI') != null || System.getenv('BUILD_NUMBER') != null

    def version_patch_lc = proj.version_patch
    if (System.getenv('BUILD_NUMBER') != null)
        version_patch_lc = System.getenv('BUILD_NUMBER')

    def version_classifier = ''
    if (System.getenv('VERSION_CLS') != null)
        version_classifier = System.getenv('VERSION_CLS')
    else if (System.getenv('NIGHTLY') != null)
        version_classifier = 'nightly'

    def version_hash = ''
    if (!build_server) {
        try {
            version_hash = "git rev-parse --short HEAD".execute().text.trim()
        } catch (all) { }
    }

    def version_base = "${proj.version_major}.${proj.version_minor}.${version_patch_lc}"
    def version_parts = ([ version_base, version_classifier, version_hash ]).findAll { p -> p != '' }

    return String.join('-', version_parts)
}

String getPrettyName(Project proj) {
    def project_base_name = rootProject.name
    if (proj.hasProperty('module_name'))
        project_base_name += "-${proj.module_name}"
    return project_base_name
}

String getArchiveBaseName(Project proj) {
    return getPrettyName(proj) + "-${project.minecraft_version}"
}
