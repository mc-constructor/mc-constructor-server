import net.minecraftforge.gradle.common.util.ModConfig

buildscript {
    repositories {
        maven { url = 'https://maven.minecraftforge.net' }
        mavenCentral()
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '5.1.+', changing: true
    }
}

apply plugin: 'idea'

// Configure all projects
subprojects {
    apply plugin: 'net.minecraftforge.gradle'
    java.toolchain.languageVersion = JavaLanguageVersion.of(16)

    // Import mod dependencies and execute
//    if (file('dependencies.gradle').exists())
//        apply from: 'dependencies.gradle'

    group = 'net.dandoes.minecraft'
    version = getVersionString(project)
    archivesBaseName = getArchiveBaseName(project)

    minecraft {
        mappings channel: 'official', version: minecraftVersion

        ModConfig projectMod = new ModConfig(project, project.moduleModId);
        projectMod.source(project.sourceSets.main)

        runs {
            client {
                workingDirectory project.file('run')

                // Recommended logging data for a userdev environment
                // The markers can be changed as needed.
                // "SCAN": For mods scan.
                // "REGISTRIES": For firing of registry events.
                // "REGISTRYDUMP": For getting the contents of all registries.
                property 'forge.logging.markers', 'REGISTRIES'

                // Recommended logging level for the console
                // You can set various levels here.
                // Please read: https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
                property 'forge.logging.console.level', 'debug'

                mods.add(projectMod)
            }

            server {
                workingDirectory project.file('run')

                property 'forge.logging.markers', 'REGISTRIES'
                property 'forge.logging.console.level', 'debug'

                mods.add(projectMod)
            }

            data {
                workingDirectory project.file('run')

                property 'forge.logging.markers', 'REGISTRIES'
                property 'forge.logging.console.level', 'debug'

                // Specify the modid for data generation, where to output the resulting resource, and where to look for existing resources.
                args '--mod', project.moduleModId, '--all', '--output', file('src/generated/resources/'), '--existing', file('src/main/resources/')

                mods.add(projectMod)
            }
        }
    }
    sourceSets.main.resources { srcDir 'src/generated/resources' }

    // Common dependencies for all modules
    dependencies {
        minecraft "net.minecraftforge:forge:${minecraftVersion}-${forgeVersion}"

//        testImplementation "org.junit.jupiter:junit-jupiter-api:5.2.0"
//        testCompile("org.junit.jupiter:junit-jupiter-api:5.2.0")
//        testCompile("org.junit.platform:junit-platform-launcher:1.1.0")
//        testRuntime("org.junit.jupiter:junit-jupiter-engine:5.2.0")
    }

    jar {
        manifest {
            attributes([
                    "Specification-Title": project.moduleModName,
                    "Specification-Vendor": "Daniel Schaffer",
                    "Specification-Version": getBaseSemverString(rootProject),
                    "Name": "${rootProject.name}/${project.name}",
                    "Implementation-Title": project.moduleName,
                    "Implementation-Version": getVersionString(rootProject),
                    "Implementation-Vendor" :"Daniel Schaffer",
                    "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
            ])
        }
    }
}

evaluationDependsOnChildren()

def clientProjects = subprojects.findAll { sp -> sp.includeWithClient == "true" }
def serverProjects = subprojects.findAll { sp -> sp.includeWithServer == "true" }

println("clientProjects:")
clientProjects.each {
    println("  " + it.name)
}
println("serverProjects:")
serverProjects.each {
    println("  " + it.name)
}

task copyServerLibJars(type: Copy, dependsOn: subprojects.tasks['reobfJar']) {
    from serverProjects.collect {it.tasks.withType(Jar) }
    into project.file('build/libs/server').path
}
task copyClientLibJars(type: Copy, dependsOn: subprojects.tasks['reobfJar']) {
    from clientProjects.collect { it.tasks.withType(Jar) }
    into project.file('build/libs/client').path
}
task copyLibJars {
    dependsOn copyServerLibJars, copyClientLibJars
}
task buildLibs {
    dependsOn copyLibJars
}

task copyClientRunJars(type: Copy, dependsOn: clientProjects.tasks['jar']) {
    from clientProjects.collect { it.tasks.withType(Jar) }
    into project.file('run/client/mods').path
}
task copyServerRunJars(type: Copy, dependsOn: serverProjects.tasks['jar']) {
    from serverProjects.collect { it.tasks.withType(Jar) }
    into project.file('run/server/mods').path
}

task prepareRuns(dependsOn: subprojects.tasks['prepareRuns']) {}

task prepareRunClient() {
    clientProjects.each { dependsOn("${it.name}:prepareRunClient") }
    dependsOn copyClientRunJars

}
task prepareRunServer() {
    serverProjects.each { dependsOn("${it.name}:prepareRunServer") }
    dependsOn copyServerRunJars
}

task cleanSubprojects {
    subprojects.each {
        delete project.fileTree('build/libs').matching {
            include "**/*.jar"
        }
        delete project.fileTree('build/reobfJar').matching {
            include "**/*.jar"
        }
    }
}

task cleanLibs {
    dependsOn cleanSubprojects
    delete project.fileTree('build/libs').matching {
        include "**/*.jar"
    }
}

task cleanRun {
    delete project.fileTree('build/run').matching {
        include "*/mods/**/*.jar"
    }
}

String[] getSemver(Project proj) {
    def semver = proj.version =~ /^(\d+)\.(\d+)\.(\d+)(?:-(\w+))?$/
    def (_, major, minor, patch, tag) = semver[0]
    return [major, minor, patch, tag]
}

String getBaseSemverString(Project proj) {
    def (major, minor, patch) = getSemver(proj)
    return "${major}.${minor}.${patch}"
}

String getVersionString(Project proj) {
    def (major, minor, patch, prereleaseQualifier) = getSemver(proj)

    String buildQualifier = System.getenv('VERSION_QUALIFIER') ?: 'snapshot'
    String qualifier = prereleaseQualifier ?: buildQualifier
    String buildId = buildQualifier == 'final' && !prereleaseQualifier ? null : (
        System.getenv('BUILD_NUMBER') ?: new Date().format("yyyyMMddHHmmss")
    )
    def result = "${major}.${minor}.${patch}-${qualifier}"
    if (buildId) {
        result += ".${buildId}"
    }
    return result
}

String getPrettyName(Project proj) {
    return "${rootProject.name}-${proj.moduleName}"
}

String getArchiveBaseName(Project proj) {
    return "${getPrettyName(proj)}-${project.minecraftVersion}"
}
